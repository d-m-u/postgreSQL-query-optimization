# Even More Theory: Algorithms
- chapter two covered relation operations and stated that we need physical operations to execute queries
- mapping these physical operations (algorithms) to logical operations is not straightforward
- this chapter describes these algorithms, starting from data retrieval and then proceeding to algorithms for more complex operations

## Algorithm Cost Models
- chapter 1 talked about ways of measuring system performance, including response time, cost, and user satisfaction: all metrics that are external to db
- external metrics are the most valuable but aren’t available to the query optimizer
-	optimizer instead uses internal metrics based on amount of computing resources needed to execute a query or a single physical operation within a plan

## Data Access Algorithms
-	in practice data access is often combined with following operation in the query execution plan which helps when we can save execution time by avoiding reading data that we’re just going to filter out
-	efficiency depends on ratio of rows that are retained to total rows in the table, a ratio which is called _selectivity_

###	Storage Structures
-	block is the unit that’s transferred between hard drive and main memory and the number of I/O operations needed to execute any data access is equal to the number of blocks that are being read or written
-	database objects consist of logical items (table rows, index records, etc)
-	several small items can reside in the same block
-	generic structure of block is as follows: header, pointers to logical items, free space, logical items, then a block trailers
-	allocation of items to blocks depends on type of database object
			table rows are stored using a heap: row can be inserted in any block with sufficient space without any specific ordering instructions

###	Full Scan
-	reads all rows in table and checks filtering condition for each row
-	cost of a full scan is c1 * BR * c2 * TR * c3 * S * TR
-	where c1, c2, c3 are constants that represent hardware properties, BR is the number of I/O accesses, the total number of iterations of filter conditions checked (total rows by total blocks) is TR, and S is selectivity

###	Index-Based Table Access
-	we do not “read” relations: they are abstract
-	there is no way to retrieve data than to read the whole table into main memory
-	but we can build indexes to make access faster than sequential read
-	two facts about indexes that are important for now: 1) they are redundant data objects, they don’t store any info that can’t also be found in the source table itself, and they provide additional data access paths, allowing us to determine what values are stored in the rows of a table without actually reading the table and is invisible to the application
-	if filtering condition is encapsulated by index, the index is used to access pointers to blocks that contain rows that satisfy the filter, and only those are read from the table
-	to get a table row from a pointer, the block containing the row must be read
-	the underlying data structure of a table is a heap: rows are unordered
-	two physical operations used by postgres to retrieve rows via index: index scan and bitmap heap scan
			index scan: database engine reads each entry of the index that satisfies the filter condition and retrieves blocks in index order
				multiple index entries might point to the same block
			to avoid multiple reads of the same block, bitmap heap scan builds a bitmap indicating the blocks that contain needed rows and then the filter is applied to all rows in those blocks
-	postgres’s implementation makes it easy to use multiple indexes on same table within the same query, by applying logical ANDs and ORs on the block bitmaps generated by each index
- cost model is much more complex: for small values of selectivity, all rows satisfying the filering conditions will be located in different blocks and consequently the cost is proportional to the number of result rows; for high selectivity values, the number of processed blocks approaches the total number of blocks and the cose becomes higher than the cost of a full scan because resources are needed to access the index

## Index-Only Scan
- data access operations don't necessarily return entire rows
- logical project operation is usually combined with data access
- algorithm reads data from the index and applies remaining filtering conditions if necessary
- usually no need to access table data but sometimes additional checks are needed (discussed more in Chapter 5)
- cost model for index-only scan is similar to model for index-based table access except there's no need to actually access table data
- small values of selectivity mean that the cost is approximately proportional to the number of returned rows
- large values of selectivity mean that the algorithm performs an almost full scan of the index
- cost of index scan is usually less than cost of full table scan cause it contains less data

##	Comparing Data Access Algorithms
- choice of the best data access algorithm depends on query selectivity
- line for full scan is linear and almost horizontal because growth is due to generalization of output
- line representing cost of index-based table access starts from almost 0 and grows quickly with growth of selectivity, slows down for large values of selectivity where the cost is significantly higher than the cost of a full scan
- most interesting point is the intersection of the two: for small selectivity, index-based access is preferable, for large values of selectivity, full scan is better
- position of intersection depends on hardware and may also depend on size of table
- line representing index-only scan is the lowest, meaning this algorithm is preferable if is applicable (i.e. all columns are in the index)
- query optimizer estimates both the selectivity of a query and the selectivity of the intersection point for this table and this index
- in reality the optimizer's job is much more complex: filtering conditions can be supported with multiple indices with different values of selectivity
- multiple indices can be combined to produce a block bitmap with fewer blocks to be scanned
- no clear winners and losers: any algorithm can be the right under certain conditions
- further, the choice of an algorithm depends on storage structure and statistical properties of the data
- db contains metadata such as column cardinality, sparseness, etc.
- usually these stats aren't known during app development and may change throughout lifecycle

## Index Structures
###	What Is an Index?
###	B-Tree Indexes
###	Why Are B-Trees Used So Often?
###	Bitmaps
	Other Kinds of Indexes

## Combining Relations
###	Nested Loops
###	Hash-Based Algorithms
###	Sort-Merge Algorithm
###	Comparing Algorithms

## Summary
